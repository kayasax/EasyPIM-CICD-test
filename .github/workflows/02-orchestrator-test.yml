name: 'Phase 2: EasyPIM Orchestrator Test'

on:
  workflow_dispatch:
    inputs:
      WhatIf:
        description: "Preview mode - show what would be done without making changes"
        required: false
        default: true
        type: boolean
      Mode:
        description: "Orchestrator execution mode (delta=incremental, initial=destructive cleanup)"
        required: false
        default: "delta"
        type: choice
        options:
          - delta
          - initial
      SkipPolicies:
        description: "Skip policy operations (assignments only)"
        required: false
        default: false
        type: boolean
      SkipAssignments:
        description: "Skip assignment operations (policies only)"
        required: false
        default: false
        type: boolean
      Force:
        description: "Force execution (bypass confirmations)"
        required: false
        default: false
        type: boolean
      Verbose:
        description: "Enable verbose output"
        required: false
        default: false
        type: boolean
      ExportWouldRemove:
        description: "Export list of items that would be removed (audit purposes)"
        required: false
        default: false
        type: boolean

env:
  KEYVAULT_NAME: ${{ vars.AZURE_KEYVAULT_NAME }}
  SECRET_NAME: ${{ vars.AZURE_KEYVAULT_SECRET_NAME }}
  TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}

permissions:
  id-token: write   # for OIDC
  contents: read

jobs:
  easypim-orchestrator:
    name: 'EasyPIM Orchestrator Execution'
    runs-on: ubuntu-latest

    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v4

      - name: 'Azure OIDC Login'
        uses: azure/login@v2
        with:
          tenant-id: ${{ env.TENANT_ID }}
          subscription-id: ${{ env.SUBSCRIPTION_ID }}
          client-id: ${{ env.AZURE_CLIENT_ID }}
          enable-AzPSSession: true

      - name: 'Install and Run EasyPIM Orchestrator'
        shell: pwsh
        run: |
          Write-Host "ÔøΩ Setting up Microsoft Graph authentication using Azure CLI token..."

          # Get Microsoft Graph access token from Azure CLI (already authenticated via OIDC)
          $graphToken = az account get-access-token --resource https://graph.microsoft.com --query accessToken --output tsv

          if (-not $graphToken) {
              Write-Error "‚ùå Failed to obtain Microsoft Graph access token from Azure CLI"
              exit 1
          }

          Write-Host "‚úÖ Successfully obtained Graph token, connecting to Microsoft Graph..."

          # Convert token to SecureString and connect to Microsoft Graph with force refresh
          $secureToken = ConvertTo-SecureString $graphToken -AsPlainText -Force

          # Ensure clean Graph session for EasyPIM compatibility
          Write-Host "üîó Connecting to Microsoft Graph with clean session..."
          Disconnect-MgGraph -ErrorAction SilentlyContinue
          Connect-MgGraph -AccessToken $secureToken -NoWelcome

          Write-Host "‚úÖ Connected to Microsoft Graph successfully"

          # Verify the connection
          $context = Get-MgContext
          if ($context) {
              Write-Host "üîç Microsoft Graph Context:"
              Write-Host "   ClientId: $($context.ClientId)"
              Write-Host "   TenantId: $($context.TenantId)"
              Write-Host "   Scopes: $($context.Scopes -join ', ')"
          } else {
              Write-Error "‚ùå Microsoft Graph context not found after connection"
              exit 1
          }

          # Connect to Azure PowerShell using OIDC as well (EasyPIM requires both!)
          Write-Host "üîó Setting up Azure PowerShell authentication for EasyPIM compatibility..."
          try {
              # Install required Azure PowerShell modules if not available (install together to share dependencies)
              $missingModules = @()
              if (-not (Get-Module -ListAvailable Az.Accounts)) {
                  $missingModules += "Az.Accounts"
              }
              if (-not (Get-Module -ListAvailable Az.KeyVault)) {
                  $missingModules += "Az.KeyVault"
              }

              if ($missingModules.Count -gt 0) {
                  Write-Host "üì¶ Installing Azure modules: $($missingModules -join ', ')..."
                  Install-Module -Name $missingModules -Force -Scope CurrentUser -AllowClobber
              }

              # Import required modules
              Import-Module Az.Accounts -Force
              Import-Module Az.KeyVault -Force

              # Check if Azure PowerShell session is already established by azure/login@v2
              Write-Host "üîó Verifying Azure PowerShell session established by azure/login@v2..."
              $azContext = Get-AzContext -ErrorAction SilentlyContinue
              if (-not $azContext) {
                  Write-Host "üîó No existing session found, connecting to Azure PowerShell with OIDC..."
                  # Since azure/login@v2 with enable-AzPSSession should handle this, try without -Identity
                  Connect-AzAccount -TenantId $env:TENANT_ID -Subscription $env:SUBSCRIPTION_ID -ErrorAction Stop
              } else {
                  Write-Host "‚úÖ Azure PowerShell session already established by azure/login@v2"
              }

              # Verify Azure PowerShell connection and set subscription context
              $azContext = Get-AzContext
              if ($azContext) {
                  # Ensure we're using the correct subscription
                  Set-AzContext -SubscriptionId $env:SUBSCRIPTION_ID -ErrorAction SilentlyContinue
                  $azContext = Get-AzContext

                  Write-Host "‚úÖ Azure PowerShell authentication successful"
                  Write-Host "   Account: $($azContext.Account)"
                  Write-Host "   Tenant: $($azContext.Tenant)"
                  Write-Host "   Subscription: $($azContext.Subscription)"
              } else {
                  Write-Warning "‚ö†Ô∏è  Azure PowerShell context not found - this may cause EasyPIM to fail"
              }
          } catch {
              Write-Warning "‚ö†Ô∏è  Primary Azure PowerShell authentication failed: $($_.Exception.Message)"
              Write-Host "ÔøΩ Attempting fallback token-based authentication..."

              try {
                  # Fallback: Get Azure management token from Azure CLI for Azure PowerShell
                  $azToken = az account get-access-token --resource https://management.azure.com/ --query accessToken --output tsv

                  if (-not $azToken) {
                      Write-Error "‚ùå Failed to obtain Azure management access token from Azure CLI"
                      exit 1
                  }

                  Write-Host "‚úÖ Successfully obtained Azure management token"

                  # Also get a Key Vault specific token for PoP authentication
                  $kvToken = az account get-access-token --resource https://vault.azure.net --query accessToken --output tsv

                  if (-not $kvToken) {
                      Write-Warning "‚ö†Ô∏è  Failed to obtain Key Vault access token - Key Vault operations may fail"
                  } else {
                      Write-Host "‚úÖ Successfully obtained Key Vault access token"
                  }

                  # Connect with both management and Key Vault tokens
                  Connect-AzAccount -AccessToken $azToken -KeyVaultAccessToken $kvToken -TenantId $env:TENANT_ID -AccountId $env:AZURE_CLIENT_ID

                  # Verify Azure PowerShell connection and set subscription context
                  $azContext = Get-AzContext
                  if ($azContext) {
                      # Ensure we're using the correct subscription
                      Set-AzContext -SubscriptionId $env:SUBSCRIPTION_ID -ErrorAction SilentlyContinue
                      $azContext = Get-AzContext

                      Write-Host "‚úÖ Fallback Azure PowerShell authentication successful"
                      Write-Host "   Account: $($azContext.Account)"
                      Write-Host "   Tenant: $($azContext.Tenant)"
                      Write-Host "   Subscription: $($azContext.Subscription)"

                      # Set ARM token environment variable for EasyPIM direct ARM API access
                      $env:AZURE_ACCESS_TOKEN = $azToken
                      $env:ARM_ACCESS_TOKEN = $azToken
                      Write-Host "‚úÖ ARM access tokens set for EasyPIM compatibility"
                  } else {
                      Write-Warning "‚ö†Ô∏è  Azure PowerShell context still not found - EasyPIM may fail"
                  }
              } catch {
                  Write-Warning "‚ö†Ô∏è  All Azure PowerShell authentication methods failed - EasyPIM may not work properly"
                  Write-Host "üîß Proceeding anyway - some EasyPIM operations might still work with Graph-only authentication"
              }
          }

          Write-Host "üöÄ Installing EasyPIM modules from PowerShell Gallery..."

          # Install modules efficiently - install both together to share dependencies
          Write-Host "üì¶ Installing EasyPIM and EasyPIM.Orchestrator (with shared dependencies)..."
          Install-Module -Name EasyPIM, EasyPIM.Orchestrator -Force -Scope CurrentUser -AllowClobber

          Write-Host "üì¶ Importing EasyPIM.Orchestrator module..."
          Import-Module EasyPIM.Orchestrator -Force

          # === ARM AUTHENTICATION HOTFIX FOR GITHUB ACTIONS OIDC ===
          Write-Host "üîß Applying ARM authentication hotfix for GitHub Actions OIDC..." -ForegroundColor Cyan

          # Get ARM token from Azure CLI (this works with azure/login@v2)
          $armToken = az account get-access-token --resource https://management.azure.com/ --query accessToken --output tsv

          if (-not $armToken) {
              Write-Error "‚ùå Failed to get ARM token from Azure CLI - OIDC setup issue"
              exit 1
          }

          # Set environment variables for EasyPIM fallback
          $env:AZURE_ACCESS_TOKEN = $armToken
          $env:ARM_ACCESS_TOKEN = $armToken

          Write-Host "‚úÖ Set ARM token environment variables for EasyPIM" -ForegroundColor Green

          # Override Invoke-ARM function to prioritize environment variable authentication
          function Invoke-ARM {
              [CmdletBinding()]
              param (
                  [Parameter(Position = 0, Mandatory = $true)]
                  [ValidateNotNullOrEmpty()]
                  [System.String]
                  $restURI,
                  [Parameter(Position = 1)]
                  [System.String]
                  $method = "GET",
                  [Parameter(Position = 2)]
                  [System.String]
                  $body = "",
                  [Parameter(Position = 3)]
                  [System.String]
                  $SubscriptionId
              )

              try {
                  # Use the token we set from Azure CLI
                  $token = $env:AZURE_ACCESS_TOKEN

                  if (-not $token) {
                      throw "No ARM access token available in environment variables"
                  }

                  $headers = @{
                      'Authorization' = "Bearer $token"
                      'Content-Type' = 'application/json'
                  }

                  $requestParams = @{
                      Uri = $restURI
                      Method = $method
                      Headers = $headers
                      ErrorAction = 'Stop'
                  }

                  if ($method -in @("POST", "PUT", "PATCH") -and $body) {
                      $requestParams.Body = $body
                  }

                  return Invoke-RestMethod @requestParams

              } catch {
                  throw "ARM API call failed: $($_.Exception.Message)"
              }
          }

          Write-Host "‚úÖ ARM authentication hotfix applied successfully" -ForegroundColor Green
          # === END HOTFIX ===

          # Test Graph API access to ensure authentication works for EasyPIM
          try {
              Write-Host "üß™ Testing Microsoft Graph API access for EasyPIM compatibility..."
              $tenant = Get-MgOrganization -ErrorAction Stop | Select-Object -First 1
              Write-Host "‚úÖ Microsoft Graph API test successful - Connected to tenant: $($tenant.DisplayName)"
          } catch {
              Write-Error "‚ùå Microsoft Graph API test failed: $($_.Exception.Message)"
              Write-Host "üîß This indicates the authentication bridge is not working properly"
              exit 1
          }

          # Force refresh the Graph authentication session to ensure EasyPIM recognizes it
          Write-Host "üîÑ Refreshing Microsoft Graph session for EasyPIM compatibility..."
          try {
              # Disconnect and reconnect to ensure clean session state
              Disconnect-MgGraph -ErrorAction SilentlyContinue

              # Reconnect with the same token but ensure fresh session
              Connect-MgGraph -AccessToken $secureToken -NoWelcome

              # Verify the fresh connection
              $newContext = Get-MgContext
              if ($newContext) {
                  Write-Host "‚úÖ Microsoft Graph session refreshed successfully"
                  Write-Host "   Session ID: $($newContext.ClientId)"
                  Write-Host "   Authentication Type: $($newContext.AuthType)"
              } else {
                  Write-Error "‚ùå Failed to refresh Microsoft Graph session"
                  exit 1
              }
          } catch {
              Write-Error "‚ùå Failed to refresh Graph session: $($_.Exception.Message)"
              exit 1
          }

          # Verify EasyPIM can detect the authentication by testing a basic command
          Write-Host "üß™ Testing EasyPIM authentication detection..."
          try {
              # Test if EasyPIM recognizes the Graph session using cmdlets it typically checks
              $authTest = Get-MgContext
              $roleTest = Get-MgDirectoryRole -ErrorAction Stop | Select-Object -First 1

              if ($authTest -and $roleTest) {
                  Write-Host "‚úÖ EasyPIM authentication prerequisites verified"
                  Write-Host "   Graph Context: Active"
                  Write-Host "   Directory Role Access: Working"
                  Write-Host "   Required scope check: $($authTest.Scopes -contains 'RoleManagement.ReadWrite.Directory')"
              } else {
                  Write-Warning "‚ö†Ô∏è  EasyPIM authentication detection uncertain"
              }
          } catch {
              Write-Error "‚ùå EasyPIM authentication test failed: $($_.Exception.Message)"
              Write-Host "üîß This may cause EasyPIM to fail authentication check"
              exit 1
          }

          # Set PowerShell execution context variables that EasyPIM might check
          Write-Host "üîß Setting authentication context for EasyPIM compatibility..."
          $env:AZURE_CLIENT_ID = $context.ClientId
          $env:AZURE_TENANT_ID = $context.TenantId

          # Also try setting these global variables that some modules check
          $global:AZURE_CLIENT_ID = $context.ClientId
          $global:AZURE_TENANT_ID = $context.TenantId

          # Try setting Microsoft Graph specific environment variables
          $env:MG_CONTEXT_TENANT_ID = $context.TenantId
          $env:MG_CONTEXT_CLIENT_ID = $context.ClientId

          # Verify EasyPIM can detect the authentication by testing a basic command
          Write-Host "üß™ Testing EasyPIM authentication detection..."
          try {
              # Test if EasyPIM recognizes the Graph session
              $authTest = Get-MgContext
              if ($authTest -and $authTest.Scopes -contains 'RoleManagement.ReadWrite.Directory') {
                  Write-Host "‚úÖ EasyPIM authentication prerequisites verified"
                  Write-Host "   Required scope 'RoleManagement.ReadWrite.Directory' found"
              } else {
                  Write-Warning "‚ö†Ô∏è  EasyPIM authentication detection uncertain - proceeding anyway"
              }
          } catch {
              Write-Warning "‚ö†Ô∏è  EasyPIM authentication test failed: $($_.Exception.Message) - proceeding anyway"
          }

          # Determine execution parameters
          $whatIf = '${{ github.event.inputs.WhatIf }}' -eq 'true'
          $mode = if ('${{ github.event.inputs.Mode }}') { '${{ github.event.inputs.Mode }}' } else { 'delta' }
          $skipPolicies = '${{ github.event.inputs.SkipPolicies }}' -eq 'true'
          $skipAssignments = '${{ github.event.inputs.SkipAssignments }}' -eq 'true'
          $force = '${{ github.event.inputs.Force }}' -eq 'true'
          $verbose = '${{ github.event.inputs.Verbose }}' -eq 'true'
          $exportWouldRemove = '${{ github.event.inputs.ExportWouldRemove }}' -eq 'true'

          Write-Host "üîß Execution Parameters:"
          Write-Host "   WhatIf: $whatIf"
          Write-Host "   Mode: $mode"
          Write-Host "   Skip Policies: $skipPolicies"
          Write-Host "   Skip Assignments: $skipAssignments"
          Write-Host "   Force: $force"
          Write-Host "   Verbose: $verbose"
          Write-Host "   Export WouldRemove: $exportWouldRemove"
          Write-Host "   Tenant ID: $env:TENANT_ID"
          Write-Host "   Subscription ID: $env:SUBSCRIPTION_ID"
          Write-Host "   Key Vault: $env:KEYVAULT_NAME"
          Write-Host "   Secret Name: $env:SECRET_NAME"

          # Build command parameters
          $orchestratorParams = @{
              'TenantId' = $env:TENANT_ID
              'SubscriptionId' = $env:SUBSCRIPTION_ID
              'Mode' = $mode
          }

          # Use Key Vault or local file
          if ($env:KEYVAULT_NAME) {
              Write-Host "üìã Using configuration from Key Vault: $env:KEYVAULT_NAME"
              $orchestratorParams['KeyVaultName'] = $env:KEYVAULT_NAME
              $orchestratorParams['SecretName'] = $env:SECRET_NAME
          } else {
              Write-Host "üìã Using local configuration file"
              $orchestratorParams['ConfigFilePath'] = "./configs/pim-config.json"
          }

          # Add conditional parameters
          if ($whatIf) {
              $orchestratorParams['WhatIf'] = $true
              Write-Host "‚ö†Ô∏è  Running in PREVIEW mode (-WhatIf)"
          } else {
              Write-Host "üö® Running in APPLY mode (changes will be made)"
          }

          if ($skipPolicies) {
              $orchestratorParams['SkipPolicies'] = $true
              Write-Host "‚è≠Ô∏è  Skipping policy operations"
          }

          if ($skipAssignments) {
              $orchestratorParams['SkipAssignments'] = $true
              Write-Host "‚è≠Ô∏è  Skipping assignment operations"
          }

          if ($force) {
              $orchestratorParams['Force'] = $true
              Write-Host "üí™ Force mode enabled (bypassing confirmations)"
          }

          if ($verbose) {
              $orchestratorParams['Verbose'] = $true
              Write-Host "üìù Verbose output enabled"
          }

          if ($exportWouldRemove) {
              $orchestratorParams['WouldRemoveExportPath'] = "./audit-exports"
              Write-Host "üì§ WouldRemove export enabled (audit purposes)"
              # Ensure export directory exists
              New-Item -ItemType Directory -Path "./audit-exports" -Force | Out-Null
          }

          # Execute EasyPIM Orchestrator with explicit Graph reconnection
          Write-Host "üéØ Executing: Invoke-EasyPIMOrchestrator"
          try {
              # One more attempt to ensure Graph connection is recognized by EasyPIM
              Write-Host "üîÑ Final Graph authentication verification for EasyPIM..."

              # Disconnect and reconnect with the exact pattern EasyPIM expects
              Disconnect-MgGraph -ErrorAction SilentlyContinue

              # Connect with access token (can't use -Scopes with -AccessToken)
              Write-Host "üîó Connecting with EasyPIM-compatible authentication..."
              Connect-MgGraph -AccessToken $secureToken -NoWelcome

              # Verify the connection one more time
              $finalContext = Get-MgContext
              if (-not $finalContext) {
                  Write-Error "‚ùå Failed to establish Graph context for EasyPIM"
                  exit 1
              }

              Write-Host "‚úÖ Final Graph context verified for EasyPIM execution"
              Write-Host "   Final Scopes: $($finalContext.Scopes -join ', ')"

              # Display final parameters for debugging
              Write-Host "üîß Final Parameters to Invoke-EasyPIMOrchestrator:"
              $orchestratorParams.GetEnumerator() | ForEach-Object { Write-Host "   $($_.Key): $($_.Value)" }

              Invoke-EasyPIMOrchestrator @orchestratorParams
              Write-Host "‚úÖ EasyPIM Orchestrator completed successfully"
          }
          catch {
              Write-Error "‚ùå EasyPIM Orchestrator failed: $_"
              throw
          }

      - name: 'Upload EasyPIM Logs'
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: easypim-logs-${{ github.run_number }}
          path: |
            LOGS/*.log
            *.log
            audit-exports/*
          retention-days: 30

  generate-summary:
    name: 'Generate Summary'
    runs-on: ubuntu-latest
    needs: easypim-orchestrator
    if: always()

    steps:
      - name: 'Generate Workflow Summary'
        run: |
          echo "# üß™ EasyPIM CI/CD Test Results - Phase 2" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow Run:** ${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Orchestrator results
          ORCHESTRATOR_STATUS="${{ needs.easypim-orchestrator.result }}"
          if [ "$ORCHESTRATOR_STATUS" = "success" ]; then
            echo "## ‚úÖ EasyPIM Orchestrator: SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "- Configuration processed successfully" >> $GITHUB_STEP_SUMMARY
            echo "- No errors encountered" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ‚ùå EasyPIM Orchestrator: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "- Orchestrator execution failed" >> $GITHUB_STEP_SUMMARY
            echo "- Check logs for detailed error information" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìä Execution Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **WhatIf Mode**: ${{ github.event.inputs.WhatIf || 'true' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Mode**: ${{ github.event.inputs.Mode || 'delta' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Skip Policies**: ${{ github.event.inputs.SkipPolicies || 'false' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Skip Assignments**: ${{ github.event.inputs.SkipAssignments || 'false' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Force**: ${{ github.event.inputs.Force || 'false' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Verbose**: ${{ github.event.inputs.Verbose || 'false' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Export WouldRemove**: ${{ github.event.inputs.ExportWouldRemove || 'false' }}" >> $GITHUB_STEP_SUMMARY

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üîó Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Review the uploaded logs for detailed execution information" >> $GITHUB_STEP_SUMMARY
          echo "2. Run Phase 3 workflow to check for policy drift" >> $GITHUB_STEP_SUMMARY
          echo "3. If running in preview mode, consider applying changes by setting WhatIf=false" >> $GITHUB_STEP_SUMMARY
          echo "4. Review EasyPIM documentation for configuration guidance" >> $GITHUB_STEP_SUMMARY

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "**üìù Note**: This is Phase 2 testing with actual EasyPIM operations." >> $GITHUB_STEP_SUMMARY
          echo "For authentication-only testing, use the Phase 1 workflow." >> $GITHUB_STEP_SUMMARY
          echo "For policy drift detection, use the Phase 3 workflow." >> $GITHUB_STEP_SUMMARY
